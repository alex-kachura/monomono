user nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

worker_rlimit_nofile 16384;

events {
   worker_connections  8192;
}

http {
  # Hide nginx version information.
  server_tokens off;

  # Allow underscore in headers
  # Strictly speakings underscores in headers is non-standard.
  # But in their great wisdom our Akamai admins defined HTTP_CLIENT_ID!
  underscores_in_headers on;

  # Define the MIME types for files.
  include       mime.types;
  default_type  application/octet-stream;

  # Format to use in log files
  log_format json '{ '
                    '"remote_addr": "$remote_addr", '
                    '"timestamp": "$time_iso8601", '
                    '"method": "$request_method", '
                    '"status": "$status", '
                    '"body_bytes_sent": "$body_bytes_sent", '
                    '"http_referer": "$http_referer", '
                    '"http_user_agent": "$http_user_agent", '
                    '"http_client_id": "$http_http_client_id", '
                    '"node_request_time": "$upstream_response_time", '
                    '"total_request_time": "$request_time", '
                    '"tracer": "$cookie_atrc"'
                  '} ';

  access_log  /var/log/nginx/access.log  json;

  # Speed up file transfers by using sendfile() to copy directly
  # between descriptors rather than using read()/write(
  sendfile        on;

  # Tell Nginx not to send out partial frames; this increases throughput
  # since TCP frames are filled up before being sent out. (adds TCP_CORK)
  #tcp_nopush     on;

  # How long to allow each connection to stay idle; longer values are better
  # for each individual client, particularly for SSL, but means that worker
  # connections are tied up longer. (Default: 65)
  keepalive_timeout  65;

  # COMPRESSION
  # Enable Gzip compressed.
  gzip  on;

  # Compression level (1-9).
  # 5 is a perfect compromise between size and cpu usage, offering about
  # 75% reduction for most ascii files (almost identical to level 9).
  gzip_comp_level 6;

  #gzip_static on;
  #gzip_http_version 1.0;
  #gzip_disable "MSIE [1-6]\.";

  # Don't compress anything that's already small and unlikely to shrink much
  # if at all (the default is 20 bytes, which is bad as that usually leads to
  # larger files after gzipping).
  gzip_min_length 1400;

  # Compress data even for clients that are connecting to us via proxies,
  # identified by the "Via" header (required for CDN's).
  gzip_proxied       any;

  #gzip_buffers 16 8k;

  # Tell proxies to cache both the gzipped and regular version of a resource
  # whenever the client's Accept-Encoding capabilities header varies;
  # Avoids the issue where a non-gzip capable client (which is extremely rare
  # today) would display gibberish if their proxy gave them the gzipped version.
  gzip_vary on;

  # Compress all output labeled with one of the following MIME-types.
  gzip_types
    application/atom+xml
    application/javascript
    application/json
    application/ld+json
    application/manifest+json
    application/rdf+xml
    application/rss+xml
    application/schema+json
    application/vnd.geo+json
    application/vnd.ms-fontobject
    application/x-font-ttf
    application/font-ttf
    application/x-font-woff
    application/font-woff
    application/x-javascript
    application/x-web-app-manifest+json
    application/xhtml+xml
    application/xml
    font/eot
    font/opentype
    image/bmp
    image/svg+xml
    image/vnd.microsoft.icon
    image/x-icon
    text/cache-manifest
    text/css
    text/javascript
    text/plain
    text/vcard
    text/vnd.rim.location.xloc
    text/vtt
    text/x-component
    text/x-cross-domain-policy
    text/xml;

  # Increase default from 8K to match that of Tesco ACE settings. Allows 20k
  # worth of headers which is necessary because of large amount of cookie
  # data.
  large_client_header_buffers 4 20k;

  upstream nodeapp {
    server app:8088;

    #absolute min number of connections to keep open
    keepalive 64;
  }

  server {
    listen              80;
    listen              443 ssl;
    ssl_certificate     ssl/tls.crt;
    ssl_certificate_key ssl/tls.key;

    # How long to allow each connection to stay idle; longer values are better
    # for each individual client, particularly for SSL, but means that worker
    # connections are tied up longer. (Default: 65)
    keepalive_timeout 10;

    # Default log file
    access_log  /var/log/nginx/access.log  json;

    # Epoch ("Thu, 01 Jan 1970 00:00:01 GMT") date for use with Expires header. Used in @node-app
    # location as "expires $epoch;" also sets the Cache-Control header, which we don't  want  (added
    # separately with additional add_header directive). We can't use "add_header Expires -1
    # always; as "-1"  value has a special meaning in Akamai (cache forever)
    set $expires_epoch "Thu, 01 Jan 1970 00:00:01 GMT";

    # Enter intial location block
    location / {
      root html;
      index  keepalive.html index.html index.htm;

      location ~* ^(/.*\.(js|css))$ {
        # Match cache-busting static assests. Capture uri after /account and attempt to fetch it
        # otherwise pass the request onto the node app. Note if we do not pass it onto @node-app
        # nignx will return it's own 404 page.

        # Set expires to max age (year 2037)
        expires max;
        etag on;

        # Try to serve the captured uri (minus the "/account") otherwise fall back to node app
        try_files $1 @node-app;
      }

      location ~* ^(/.*\.(html|png|gif|jpg|jpeg|ico|woff|svg|ttf|eot))$ {
          # Match non cache-busting static assests. Capture uri after /account and attempt to fetch
          # it otherwise pass the request onto the node app. Note if we do not pass it onto the node
          # app nignx will return it's own 404 page.

          # Set expires to 2d from request date.
          expires 2d;
          etag on;

          # Try to serve the captured uri (minus the "/account") otherwise fall back to node app
          try_files $1 @node-app;
        }

      # If no location block matches attempt to serve the content directly, otherwise pass it onto
      # the node  application
      try_files $uri @node-app;
    }

    # Node Application block, proxy requests to node
    location @node-app {
      proxy_set_header X-Real-IP          $remote_addr;
      proxy_set_header X-Forwarded-For    $proxy_add_x_forwarded_for;
      proxy_set_header Host               $http_host;
      proxy_set_header X-NginX-Proxy      true;
      proxy_set_header Connection         "";
      proxy_set_header X-Server           "passthroughFromNode";
      proxy_http_version                  1.1;
      proxy_pass                          http://nodeapp;
      proxy_buffering                     on;
      proxy_buffer_size                   20k;
      proxy_busy_buffers_size             20k;

      # Express automatically adds an  ETag header - If that changes and is required,set  to "on"
      etag off;

      # Add HSTS header to force a secure connection
      add_header Strict-Transport-Security "max-age=31536000" always;

      # Add explicit cache control headers. We can't use expires -1 as Akamai treats this as cache
      # forever command. So we manually set Expires 1 JAN 1970 (see $expires_epoch above).
      # Additionally set the  Cache-Control to explicit ask for no caching.
      add_header Cache-Control "private, no-cache, no-transform" always;
      add_header Expires $expires_epoch always;
    }

    location /500.html {
      root /home/node/dist;
    }

    error_page 500 502 503 504 /500.html;
  }
}
